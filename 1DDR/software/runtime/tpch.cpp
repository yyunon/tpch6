// Copyright 2018 Delft University of Technology
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <memory>
#include <iostream>
#include <chrono>

#include <arrow/api.h>
#include <fletcher/api.h>

#ifdef SV_TEST
#include "fletcher_aws_sim.h"
#endif

#define MAX_STRBUF_SIZE 256
#define NAME_SUFFIX_LENGTH 7 // 000.rb (3 numbers, 3 chars, and a terminator)

inline double fixed_to_float(uint64_t input)
{
  return ((double)input / (double)(1 << 18));
}

#ifdef SV_TEST

//fw decl
int tpch_main(int argc, char **argv);
extern "C" void test_main(uint32_t *exit_code)
{

  printf("tpch.cpp test_main simulation runtime entry point\n");

  char *rb_base = getenv("TEST_RECORDBATCH_BASE");
  if (rb_base)
  {
    //printf("TEST_RECORDBATCH_BASE: %s", rb_base ); //do not try to print this because it is not terminated
  }
  else
  {
    printf("Error: TEST_RECORDBATCH_BASE not found.\n");
    printf("Please set this environment variable to the location (including the path) "
           "of the test recordbatches generated by tpch.py, excluding the number+extension suffix (000.rb).\n");
    printf("For example: `export TEST_RECORDBATCH_BASE=~/workspaces/tpch/gen/rematch`.\n");
    exit_code = 0;
    return;
  }

  char *argv[] = {(char *)"tpch", rb_base, (char *)"1", (char *)"2"};
  if (tpch_main(4, argv) == 0)
  {
    *exit_code = 1;
  }
  else
  {
    *exit_code = 0;
  }
}

int tpch_main(int argc, char **argv)
{

#else  //!SV_TEST

//Entry point for normal operation (not simulating)
int main(int argc, char **argv)
{
#endif //SV_TEST

  printf("\n\ttpch - Regular Expression matcher FPGA circuit generator - runtime\n\n");
  // Check number of arguments.
  if (argc != 4)
  {
    std::cerr << "Incorrect number of arguments. Usage: \n\ttpch <recordbatch_basename> "
              << "<nkernels> <nOutputs> [sim]\n"
              << "The recordbatch_basename will be appended with the number 000 - nKernels, "
              << "so if you have 15 kernels you should have recordbatch_basename000.rb up to "
              << "recordbatch_basename015.rb in your working directory."
              << "nKernels \tThe number of kernels in your hardware design"
              << "nOutputs \tThe number of regular expressions in your hardware design"
              << std::endl;
    return -1;
  }

  int nKernels = (uint32_t)std::strtoul(argv[2], nullptr, 10);
  int nOutputs = (uint32_t)std::strtoul(argv[3], nullptr, 10);

  std::vector<std::shared_ptr<arrow::RecordBatch>> batches;
  std::shared_ptr<arrow::RecordBatch> number_batch;
  int nameLen = strnlen(argv[1], MAX_STRBUF_SIZE);
  if (nameLen <= 0)
  {
    std::cerr << "Something is wrong with the recordbatch basename." << std::endl;
    return -1;
  }
  char *nameBuf = (char *)malloc(nameLen + NAME_SUFFIX_LENGTH);
  strncpy(nameBuf, argv[1], nameLen + NAME_SUFFIX_LENGTH);
  nameBuf[nameLen + NAME_SUFFIX_LENGTH] = '\0'; //terminate the string

  // Attempt to read the RecordBatches from the supplied argument.
  for (int i = 0; i < nKernels; i++)
  {
    snprintf(nameBuf + nameLen, MAX_STRBUF_SIZE, "%03d.rb", i);
    fletcher::ReadRecordBatchesFromFile(nameBuf, &batches);
  }

  // RecordBatch should contain exactly one batch.
  if (batches.size() != (uint32_t)nKernels)
  {
    std::cerr << "Your set of files does not contain enough Arrow RecordBatches (" << batches.size()
              << ") for the specified number of kernels (" << nKernels << ")." << std::endl;
    return -1;
  }

  fletcher::Status status;
  std::shared_ptr<fletcher::Platform> platform;
  std::shared_ptr<fletcher::Context> context;

  auto t_total_start = std::chrono::high_resolution_clock::now();
  // Create a Fletcher platform object, attempting to autodetect the platform.
#ifdef SV_TEST
  status = fletcher::Platform::Make("aws_sim", &platform);
#else
  // Create a Fletcher platform object, attempting to autodetect the platform.
  auto t_platform_create_start = std::chrono::high_resolution_clock::now();
  status = fletcher::Platform::Make("aws", &platform);
  auto t_platform_create_end = std::chrono::high_resolution_clock::now();
#endif

  if (!status.ok())
  {
    std::cerr << "Could not create Fletcher platform." << std::endl;
    return -1;
  }

  // Initialize the platform.
#ifdef SV_TEST
  InitOptions options = {1}; //do not initialize DDR for the 1DDR version
  platform->init_data = &options;
#endif
  // Initialize the platform.
  auto t_platform_init_start = std::chrono::high_resolution_clock::now();
  status = platform->Init();
  auto t_platform_init_end = std::chrono::high_resolution_clock::now();

  if (!status.ok())
  {
    std::cerr << "Could not initialize Fletcher platform." << std::endl;
    return -1;
  }

  // Create a context for our application on the platform.
  auto t_context_start = std::chrono::high_resolution_clock::now();
  status = fletcher::Context::Make(&context, platform);
  auto t_context_end = std::chrono::high_resolution_clock::now();

  if (!status.ok())
  {
    std::cerr << "Could not create Fletcher context." << std::endl;
    return -1;
  }

  // Queue the recordbatch to our context.
  auto t_rb_start = std::chrono::high_resolution_clock::now();
  for (int i = 0; i < nKernels; i++)
  {
    status = context->QueueRecordBatch(batches[i]);

    if (!status.ok())
    {
      std::cerr << "Could not queue RecordBatch " << i << " to the context." << std::endl;
      return -1;
    }
  }
  auto t_rb_end = std::chrono::high_resolution_clock::now();
  // "Enable" the context, potentially copying the recordbatch to the device. This depends on your platform.
  // AWS EC2 F1 requires a copy, but OpenPOWER SNAP doesn't.
  auto t_enable_ctx_start = std::chrono::high_resolution_clock::now();
  context->Enable();
  auto t_enable_ctx_end = std::chrono::high_resolution_clock::now();

  if (!status.ok())
  {
    std::cerr << "Could not enable the context." << std::endl;
    return -1;
  }

  // Create a kernel based on the context.
  auto t_create_krnl_start = std::chrono::high_resolution_clock::now();
  fletcher::Kernel kernel(context);
  auto t_create_krnl_end = std::chrono::high_resolution_clock::now();

  // Start the kernel.
  auto t_reset_krnl_start = std::chrono::high_resolution_clock::now();
  status = kernel.Reset();
  auto t_reset_krnl_end = std::chrono::high_resolution_clock::now();

  if (!status.ok())
  {
    std::cerr << "Could not start the kernel." << std::endl;
    return -1;
  }

  // Start the kernel.
  auto t_start_krnl_start = std::chrono::high_resolution_clock::now();
  status = kernel.Start();
  auto t_start_krnl_end = std::chrono::high_resolution_clock::now();

  if (!status.ok())
  {
    std::cerr << "Could not start the kernel." << std::endl;
    return -1;
  }

  // Wait for the kernel to finish.
  auto t_poll_krnl_start = std::chrono::high_resolution_clock::now();
  status = kernel.PollUntilDone();
  auto t_poll_krnl_end = std::chrono::high_resolution_clock::now();

  if (!status.ok())
  {
    std::cerr << "Something went wrong waiting for the kernel to finish." << std::endl;
    return -1;
  }

  // Obtain the return value.
  uint32_t return_value_0;
  uint32_t return_value_1;
  auto t_get_return_start = std::chrono::high_resolution_clock::now();
  status = kernel.GetReturn(&return_value_0, &return_value_1);

  if (!status.ok())
  {
    std::cerr << "Could not obtain the return value." << std::endl;
    return -1;
  }

  uint32_t rhigh;
  uint32_t rlow;
  uint64_t result;
  for (int i = 0; i < nOutputs; i++)
  {
    uint64_t value;
    uint64_t offset = FLETCHER_REG_SCHEMA + 2 * context->num_recordbatches() + 2 * context->num_buffers() + i;
    platform->ReadMMIO64(offset, &value);
    value &= 0xffffffff; //the count registers are 32 bits wide, not 64
    if (i == 0)
      rhigh = (uint32_t)value;
    else
      rlow = (uint32_t)value;
  }
  result = rhigh;
  result = (result << 32) | rlow;
  auto t_get_return_end = std::chrono::high_resolution_clock::now();
  auto t_total_end = std::chrono::high_resolution_clock::now();
  // Print the return value.
  std::cout << "Return value: " << fixed_to_float(result) << std::endl;
    //Calculate durations
  auto t_platform_create = std::chrono::duration_cast<std::chrono::microseconds>(t_platform_create_end - t_platform_create_start).count();
  auto t_platform_init = std::chrono::duration_cast<std::chrono::microseconds>(t_platform_init_end - t_platform_init_start).count();
  auto t_context = std::chrono::duration_cast<std::chrono::microseconds>(t_context_end - t_context_start).count();
  auto t_rb = std::chrono::duration_cast<std::chrono::microseconds>(t_rb_end - t_rb_start).count();
  auto t_enable_ctx = std::chrono::duration_cast<std::chrono::microseconds>(t_enable_ctx_end - t_enable_ctx_start).count();
  auto t_create_krnl = std::chrono::duration_cast<std::chrono::microseconds>(t_create_krnl_end - t_create_krnl_start).count();
  auto t_reset_krnl = std::chrono::duration_cast<std::chrono::microseconds>(t_reset_krnl_end - t_reset_krnl_start).count();
  auto t_start_krnl = std::chrono::duration_cast<std::chrono::microseconds>(t_start_krnl_end - t_start_krnl_start).count();
  auto t_poll_krnl = std::chrono::duration_cast<std::chrono::microseconds>(t_poll_krnl_end - t_poll_krnl_start).count();
  auto t_get_return = std::chrono::duration_cast<std::chrono::microseconds>(t_get_return_end - t_get_return_start).count();
  auto t_total = std::chrono::duration_cast<std::chrono::microseconds>(t_total_end - t_total_start).count();
    // Print durations.
  std::cout << "Create platform: \t" << t_platform_create << "us" << std::endl;
  std::cout << "Init platform: \t\t" << t_platform_init << "us" << std::endl;
  std::cout << "Create context: \t" << t_context << "us" << std::endl;
  std::cout << "Queue recordbatch: \t" << t_rb << "us" << std::endl;
  std::cout << "Enable context: \t" << t_enable_ctx << "us" << std::endl;
  std::cout << "Create kernel: \t\t" << t_create_krnl << "us" << std::endl;
  std::cout << "Reset kernel: \t\t" << t_reset_krnl << "us" << std::endl;
  std::cout << "Start kernel: \t\t" << t_start_krnl << "us" << std::endl;
  std::cout << "Waiting for kernel: \t" << t_poll_krnl << "us" << std::endl;
  std::cout << "Get return value: \t" << t_get_return << "us" << std::endl;
  std::cout << "Total runtime: \t\t" << t_total << "us" << std::endl;

  return 0;
}
